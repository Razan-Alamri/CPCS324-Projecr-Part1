
/* CPCS324 Project Part 1

 Group members: 
    1- Razan Alamri
    2- Khloud Alsofyani
    3- Leen Ba Galaql
    4- Shatha Binmahfouz
 */
package GraphFramework;

import java.util.*;

import PhoneNetworkApp.Line;
import PhoneNetworkApp.Office;

/* MHPrimAlg is a subclass of MSTAlgorithm that implements the minimum spanning tree
 *  algorithm using the modified heap-based Prim's algorithm.
 */
public class MHPrimAlg extends MSTAlgorithm {

    public MHPrimAlg(Graph graph) {
        super(graph);
    }

    /*
     * Override method responsible for displaying the minimum spanning tree
     * generated by the min-heap based Prim algorithm
     */
    public void displayResultingMST(boolean isFile) {

        boolean[] In_HP = new boolean[graph.verticesNo];

        HeapNode[] hP_Nodes = new HeapNode[graph.verticesNo];

        MSTResultList = new Line[graph.verticesNo];

        /*
         * Initialize the min-heap and the MST result list using the graph data
         */
        for (int i = 0; i < graph.verticesNo; i++) {

            hP_Nodes[i] = new HeapNode(graph.vertices[i], Integer.MAX_VALUE);

            MSTResultList[i] = graph.creatEdge();
            In_HP[i] = true;
        }

        hP_Nodes[0].key = 0;

        minHeap Min_heap = new minHeap(graph.verticesNo);

        for (int i = 0; i < graph.verticesNo; i++) {
            Min_heap.insert(hP_Nodes[i]);
        }

        while (!Min_heap.isEmpty()) {

            HeapNode eXtract_MNode = Min_heap.extractMin();

            Vertex eXtract_Vertex = eXtract_MNode.vertex;

            In_HP[eXtract_Vertex.ID] = false;

            LinkedList<Edge> list = eXtract_Vertex.adjList;

            /*
             * Update the min-heap and the MST result list using the extracted vertex
             */
            for (int i = 0; i < list.size(); i++) {

                Edge edge = list.get(i);

                if (In_HP[edge.target.ID]) {

                    int Targ_et = edge.target.ID;

                    int TESt_weight = edge.weight;

                    if (hP_Nodes[Targ_et].key > TESt_weight) {

                        decreaseKey(Min_heap, TESt_weight, Targ_et);

                        MSTResultList[Targ_et].parent = eXtract_Vertex;

                        MSTResultList[Targ_et].target = edge.target;

                        MSTResultList[Targ_et].weight = TESt_weight;

                        hP_Nodes[Targ_et].key = TESt_weight;
                    }
                }
            }
        }

        /*
         * Display the minimum spanning tree and the information of all vertices
         * and edges in the graph if "isFile" is false, otherwise print only the graph
         * that was read from file along with the cost of the designed phone network
         */

        if (isFile) {
            int cost = 0;
            System.out.println(
                    "\nThe phone network (minimum spanning tree) generated by min-heap based Prim algorithm is as follows:\n");
            for (int i = 1; i < MSTResultList.length; i++) {
                Edge edge = MSTResultList[i];
                edge.displyInfo();
                cost += edge.weight;
            }
            System.out.println("\nThe cost of designed phone network: " + cost);
        }

    }

    /*
     * Helper method for decreasing the key of a node in the min-heap
     */
    public void decreaseKey(minHeap minHeap, int TESt_weight, int vertex) {

        int index = minHeap.indexes[vertex];

        HeapNode node = minHeap.minHeapArray[index];
        node.key = TESt_weight;
        minHeap.bubbleUp(index);
    }
}

/*
 * Class representing a heap node that contains a vertex and its key value
 */
class HeapNode {

    Vertex vertex;

    int key;

    public HeapNode() {
    }

    public HeapNode(Vertex vertex, int key) {
        this.vertex = vertex;
        this.key = key;
    }

}

/*
 * Class representing a min-heap data structure
 */
class minHeap {

    int size;

    int currentSize;

    HeapNode[] minHeapArray;

    int[] indexes;

    public minHeap(int size) {
        this.size = size;
        minHeapArray = new HeapNode[size + 1];
        indexes = new int[size];
        minHeapArray[0] = new HeapNode(new Office(), Integer.MIN_VALUE);
        minHeapArray[0].vertex.ID = -1;
        currentSize = 0;
    }

    /*
     * Helper method for displaying the contents of the min-heap
     */
    public void display() {
        for (int i = 0; i <= currentSize; i++) {
            System.out.println(" " + minHeapArray[i].vertex + "   key   " + minHeapArray[i].key);
        }
        System.out.println("________________________");
    }

    /*
     * Helper method for inserting a node into the min-heap
     */
    public void insert(HeapNode node) {
        currentSize++;
        int Index = currentSize;
        minHeapArray[Index] = node;
        indexes[node.vertex.ID] = Index;
        bubbleUp(Index);
    }

    /*
     * Helper method for bubbling up a node in the min-heap
     */
    public void bubbleUp(int num) {
        int parentIndex = num / 2;
        int currentIndex = num;
        while (currentIndex > 0 && minHeapArray[parentIndex].key > minHeapArray[currentIndex].key) {
            HeapNode currentNode = minHeapArray[currentIndex];
            HeapNode parentNode = minHeapArray[parentIndex];

            indexes[currentNode.vertex.ID] = parentIndex;
            indexes[parentNode.vertex.ID] = currentIndex;
            swap(currentIndex, parentIndex);
            currentIndex = parentIndex;
            parentIndex = parentIndex / 2;
        }
    }

    /*
     * Helper method for extracting the minimum node from the min-heap
     */
    public HeapNode extractMin() {
        HeapNode min = minHeapArray[1];
        HeapNode lastNode = minHeapArray[currentSize];
        indexes[lastNode.vertex.ID] = 1;
        minHeapArray[1] = lastNode;
        minHeapArray[currentSize] = null;
        sinkDown(1);
        currentSize--;
        return min;
    }

    /*
     * Helper method for sinking down a node in the min-heap
     */
    public void sinkDown(int k) {
        int smallest = k;
        int leftChildIndex = 2 * k;
        int rightChildIndex = 2 * k + 1;
        if (leftChildIndex < heapSize() && minHeapArray[smallest].key > minHeapArray[leftChildIndex].key) {
            smallest = leftChildIndex;
        }
        if (rightChildIndex < heapSize() && minHeapArray[smallest].key > minHeapArray[rightChildIndex].key) {
            smallest = rightChildIndex;
        }
        if (smallest != k) {

            HeapNode smallestNode = minHeapArray[smallest];
            HeapNode kNode = minHeapArray[k];

            indexes[smallestNode.vertex.ID] = k;
            indexes[kNode.vertex.ID] = smallest;
            swap(k, smallest);
            sinkDown(smallest);
        }
    }

    /*
     * Helper method for swapping two nodes in the min-heap
     */
    public void swap(int num1, int num2) {
        HeapNode temp = minHeapArray[num1];
        minHeapArray[num1] = minHeapArray[num2];
        minHeapArray[num2] = temp;
    }

    /*
     * Helper method for checking if the min-heap is empty
     */
    public boolean isEmpty() {
        return currentSize == 0;
    }

    /*
     * Helper method for getting the size of the min-heap
     */
    public int heapSize() {
        return currentSize;
    }
}